---
layout: post
title: 解耦套路之 AOP
categories: DesignPatterns
description: 解读那些解耦套路
keywords: AOP
---
AOP（Aspect Oriented Programming）意为：面向切面编程，它是一种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想。用于切入到指定类指定方法的代码片段叫做切面，而切入到哪些类中的哪些方法叫做切入点。

### 为什么需要 AOP
iOS 开发当中不可避免的要与`UIViewController`打交道，一个项目当中可能有很多`UIViewController`的子类，像下面这样：
```
// ViewControllerA
@interface ViewControllerA:UIViewController

@end

@implementation ViewControllerA

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view.
}

@end

// ViewControllerB
@interface ViewControllerB:UIViewController

@end

@implementation ViewControllerB

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view.
}
@end

```

但如果需要在`viewDidLoad`方法里进行一些统计，使用面向对象的思路，我们可能会这样做：
```
//添加一个统计类
@interface Reporter:NSObject
- (void)record:(NSString *)message;
@end
@implementation Reporter

- (void)record:(NSString *)message{
    // do something
}
@end

@interface ViewControllerA:UIViewController
@end
@implementation ViewControllerA

- (void)viewDidLoad {
    [super viewDidLoad];
    //调用统计代码
    Reporter *reporter = [Reporter new];
    [reporter record:@"something..."];
}
@end

@interface ViewControllerB:UIViewController
@end
@implementation ViewControllerB

- (void)viewDidLoad {
    [super viewDidLoad];
    //调用统计代码
    Reporter *reporter = [Reporter new];
    [reporter record:@"something..."];
}
@end

```

这样做其实已经产生了耦合，每个`UIViewController`的`viewDidLoad`方法都要写上`Reporter`的代码，当需要记录的信息越来越多时就会变得很臃肿。

或许你会想，我像这样建个基类不就可以了吗？
```
@interface RootController:UIViewController
@end
@implementation RootController

- (void)viewDidLoad {
    [super viewDidLoad];
    Reporter *reporter = [Reporter new];
    [reporter record:@"something..."];
}
@end

@interface ViewControllerA:RootController
@end
@implementation ViewControllerA

- (void)viewDidLoad {
    [super viewDidLoad];
}
@end

@interface ViewControllerB:RootController
@end
@implementation ViewControllerB

- (void)viewDidLoad {
    [super viewDidLoad];
}
@end

```

确实，理论上需要用 AOP 解决的问题，OOP 也可以解决，但这并非是高效的做法，这样做就需要多维护一个`RootController`类，并且如果其他工程需要用到`ViewControllerA`和`ViewControllerB`，也不方便直接移植过去。

这个问题的本质在于**如何增强对象的方法**，OOP可以解决，但 AOP 可以更加高效优雅的解决。

## 使用 AOP 增强对象的方法
AOP 思想是在在运行时，动态地将代码切入到类的指定方法、指定位置上，以此来**如何增强对象的方法**。

本文示例采用的是 OC 语言，这里使用 Aspects 库来解决这个问题：

```
[UIViewController aspect_hookSelector:@selector(viewDidLoad:) withOptions:AspectPositionAfter usingBlock:^(id<AspectInfo> aspectInfo, BOOL animated) {
    Reporter *reporter = [Reporter new];
    [reporter record:@"something..."];
} error:NULL];
@end
```
使用 AOP 切入了`UIViewController`的`viewDidLoad`方法后，补充调用了`Reporter`，轻松实现了解耦。

[Aspects](https://github.com/steipete/Aspects) 库是基于`runtime`实现的，提供了更完善的切入时机：
```
typedef NS_OPTIONS(NSUInteger, AspectOptions) {
    AspectPositionAfter   = 0,            /// Called after the original implementation (default)
    AspectPositionInstead = 1,            /// Will replace the original implementation.
    AspectPositionBefore  = 2,            /// Called before the original implementation.
    
    AspectOptionAutomaticRemoval = 1 << 3 /// Will remove the hook after the first execution.
};
```

滥用`runtime`会带来一些一些意想不到的异常，如果有日志统计方面的需求要用到 AOP，强烈推荐使用 Aspects，框架内部提供了较完善的异常处理和测试，不要再自己手去做`Method Swizzling`了...

---
layout: post
title: Node.js 运行机制详解
categories: Node
description: some word here
keywords: 异步IO，非阻塞，单线程，事件驱动
---

Node.js 是运行在服务器上的 JavaScript, 具备异步IO、非阻塞、单线程、事件驱动等特性。之前对这些特性的理解只是通过一些博客，始终不得要领。最近读了朴灵的《深入浅出 Node.js》，对此有了更清晰明确的认识。

## 服务器模型变迁
从“古”到今，Web服务器的架构已经历了几次变迁。服务器处理客户端请求的并发量，就是每个里程碑的见证。
### 石器时代:同步
最早的服务器，其执行模型是同步的，它的服务模式是一次只为一个请求服务，所有请求都 得按次序等待服务。这意味除了当前的请求被处理外，其余请求都处于耽误的状态。它的处理能 力相当低下，假设每次响应服务耗用的时间稳定为N秒，这类服务的QPS为1/N。
这类架构如今已基本被淘汰，只在一些无并发要求的应用中存在。
### 青铜时代:复制进程
为了解决同步架构的并发问题，一个简单的改进是通过进程的复制同时服务更多的请求和用 户。这样每个连接都需要一个进程来服务，即100个连接需要启动100个进程来进行服务，这是非 常昂贵的代价。在进程复制的过程中，需要复制进程内部的状态，对于每个连接都进行这样的复 制的话，相同的状态将会在内存中存在很多份，造成浪费。并且这个过程由于要复制较多的数据， 启动是较为缓慢的。
为了解决启动缓慢的问题，预复制(prefork)被引入服务模型中，即预先复制一定数量的进 程。同时将进程复用，避免进程创建、销毁带来的开销。但是这个模型并不具备伸缩性，一旦并 发请求过高，内存使用随着进程数的增长将会被耗尽。
假设通过进行复制和预复制的方式搭建的服务器有资源的限制，且进程数上限为M，那这类 服务的QPS为M/N。
### 白银时代:多线程
为了解决进程复制中的浪费问题，多线程被引入服务模型，让一个线程服务一个请求。线程相 对进程的开销要小许多，并且线程之间可以共享数据，内存浪费的问题可以得到解决，并且利用线 程池可以减少创建和销毁线程的开销。但是多线程所面临的并发问题只能说比多进程略好，因为每 个线程都拥有自己独立的堆栈，这个堆栈都需要占用一定的内存空间。另外，由于一个CPU核心在 一个时刻只能做一件事情，操作系统只能通过将CPU切分为时间片的方法，让线程可以较为均匀地 使用CPU资源，但是操作系统内核在切换线程的同时也要切换线程的上下文，当线程数量过多时， 时间将会被耗用在上下文切换中。所以在大并发量时，多线程结构还是无法做到强大的伸缩性。
如果忽略掉多线程上下文切换的开销，假设线程所占用的资源为进程的1/L，受资源上限的 影响，它的QPS则为M * L/N。
### 黄金时代:事件驱动
多线程的服务模型服役了很长一段时间，Apache就是采用多线程/多进程模型实现的，当并 发增长到上万时，内存耗用的问题将会暴露出来，这即是著名的C10k问题。
为了解决高并发问题，基于事件驱动的服务模型出现了，像Node与Nginx均是基于事件驱动 的方式实现的，采用单线程避免了不必要的内存开销和上下文切换开销。基于事件的服务模型存在的问题即是本章起始时提及的两个问题:CPU的利用率和进程的健
壮性。单线程的架构并不少见，其中尤以PHP最为知名——在PHP中没有线程的支持。它的健壮 性是由它给每个请求都建立独立的上下文来实现的。但是对于Node来说，所有请求的上下文都是 统一的，它的稳定性是亟需解决的问题。
由于所有处理都在单线程上进行，影响事件驱动服务模型性能的点在于CPU的计算能力，它 的上限决定这类服务模型的性能上限，但它不受多进程或多线程模式中资源上限的影响，可伸缩 性远比前两者高。如果解决掉多核CPU的利用问题，带来的性能上提升是可观的。